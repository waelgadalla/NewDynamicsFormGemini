@* Validation settings section *@
@implements IDisposable
@using VisualEditorOpus.Components.Editor.Modals
@using DynamicForms.Core.V4.Schemas

<PropertySection Title="Validation" Icon="bi-shield-check">
    <div class="checkbox-group" @onclick="ToggleRequired">
        <input type="checkbox" checked="@(Field?.Validation?.IsRequired == true)" />
        <span style="font-size: 12px;">Required</span>
    </div>

    @if (Field?.Validation?.IsRequired == true)
    {
        <div class="prop-group" style="margin-top: 12px;">
            <label class="prop-label">Required Message</label>
            <BilingualInput ValueEn="@Field?.Validation?.RequiredMessageEn"
                            ValueFr="@Field?.Validation?.RequiredMessageFr"
                            ValueEnChanged="HandleRequiredMsgEnChange"
                            ValueFrChanged="HandleRequiredMsgFrChange"
                            PlaceholderEn="This field is required"
                            PlaceholderFr="Ce champ est obligatoire" />
        </div>
    }

    @if (IsTextField)
    {
        <div class="prop-row" style="margin-top: 12px;">
            <div class="prop-group">
                <label class="prop-label">Min Length</label>
                <input type="number" class="prop-input" min="0"
                       value="@Field?.Validation?.MinLength"
                       @onchange="HandleMinLengthChange" />
            </div>
            <div class="prop-group">
                <label class="prop-label">Max Length</label>
                <input type="number" class="prop-input" min="0"
                       value="@Field?.Validation?.MaxLength"
                       @onchange="HandleMaxLengthChange" />
            </div>
        </div>

        <div class="prop-group">
            <label class="prop-label">Pattern (Regex)</label>
            <input type="text" class="prop-input text-mono"
                   value="@Field?.Validation?.Pattern"
                   placeholder="e.g., ^[A-Z]{2}\\d{6}$"
                   @onchange="HandlePatternChange" />
        </div>
    }

    @if (IsNumericField)
    {
        <div class="prop-row" style="margin-top: 12px;">
            <div class="prop-group">
                <label class="prop-label">Min Value</label>
                <input type="number" class="prop-input"
                       value="@Field?.Validation?.MinValue"
                       @onchange="HandleMinValueChange" />
            </div>
            <div class="prop-group">
                <label class="prop-label">Max Value</label>
                <input type="number" class="prop-input"
                       value="@Field?.Validation?.MaxValue"
                       @onchange="HandleMaxValueChange" />
            </div>
        </div>
    }

    @* Cross-Field Validation Section *@
    <div class="prop-group" style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border-color);">
        <label class="prop-label">Cross-Field Validation</label>
        <button class="btn btn-outline btn-sm" style="width: 100%;" @onclick="ShowCrossFieldValidation" type="button">
            <i class="bi bi-link-45deg"></i>
            Add Cross-Field Rule
        </button>
        @if (CrossFieldValidationCount > 0)
        {
            <p class="form-hint" style="margin-top: 8px;">
                @CrossFieldValidationCount cross-field rule(s) configured at module level
            </p>
        }
    </div>
</PropertySection>

@* Cross-Field Validation Modal *@
@if (EditorState.CurrentModule is not null)
{
    <CrossFieldValidationModal @bind-IsOpen="_showCrossFieldModal"
                                ExistingValidation="_editingValidation"
                                CurrentModule="EditorState.CurrentModule"
                                OnSave="HandleCrossFieldSaved"
                                OnCancel="CloseCrossFieldModal" />
}

@code {
    [Inject] private IEditorStateService EditorState { get; set; } = default!;

    private FormFieldSchema? Field => EditorState.SelectedField;
    private bool IsTextField => Field?.FieldType is "TextBox" or "TextArea";
    private bool IsNumericField => Field?.FieldType is "Number" or "Currency";

    // Cross-field validation state
    private bool _showCrossFieldModal;
    private FieldSetValidation? _editingValidation;
    private int CrossFieldValidationCount => EditorState.CurrentModule?.CrossFieldValidations?.Length ?? 0;

    protected override void OnInitialized()
    {
        EditorState.OnFieldSelected += OnFieldSelected;
    }

    private FieldValidationConfig GetOrCreateValidation()
    {
        return Field?.Validation ?? new FieldValidationConfig();
    }

    private void ToggleRequired()
    {
        if (Field is null) return;
        var validation = GetOrCreateValidation();
        var updated = Field with { Validation = validation with { IsRequired = !validation.IsRequired } };
        EditorState.UpdateField(updated);
    }

    private void HandleRequiredMsgEnChange(string? value)
    {
        if (Field is null) return;
        var validation = GetOrCreateValidation();
        var updated = Field with { Validation = validation with { RequiredMessageEn = value } };
        EditorState.UpdateField(updated);
    }

    private void HandleRequiredMsgFrChange(string? value)
    {
        if (Field is null) return;
        var validation = GetOrCreateValidation();
        var updated = Field with { Validation = validation with { RequiredMessageFr = value } };
        EditorState.UpdateField(updated);
    }

    private void HandleMinLengthChange(ChangeEventArgs e)
    {
        if (Field is null) return;
        var validation = GetOrCreateValidation();
        int? value = int.TryParse(e.Value?.ToString(), out var v) ? v : null;
        var updated = Field with { Validation = validation with { MinLength = value } };
        EditorState.UpdateField(updated);
    }

    private void HandleMaxLengthChange(ChangeEventArgs e)
    {
        if (Field is null) return;
        var validation = GetOrCreateValidation();
        int? value = int.TryParse(e.Value?.ToString(), out var v) ? v : null;
        var updated = Field with { Validation = validation with { MaxLength = value } };
        EditorState.UpdateField(updated);
    }

    private void HandlePatternChange(ChangeEventArgs e)
    {
        if (Field is null) return;
        var validation = GetOrCreateValidation();
        var updated = Field with { Validation = validation with { Pattern = e.Value?.ToString() } };
        EditorState.UpdateField(updated);
    }

    private void HandleMinValueChange(ChangeEventArgs e)
    {
        if (Field is null) return;
        var validation = GetOrCreateValidation();
        double? value = double.TryParse(e.Value?.ToString(), out var v) ? v : null;
        var updated = Field with { Validation = validation with { MinValue = value } };
        EditorState.UpdateField(updated);
    }

    private void HandleMaxValueChange(ChangeEventArgs e)
    {
        if (Field is null) return;
        var validation = GetOrCreateValidation();
        double? value = double.TryParse(e.Value?.ToString(), out var v) ? v : null;
        var updated = Field with { Validation = validation with { MaxValue = value } };
        EditorState.UpdateField(updated);
    }

    private void OnFieldSelected(string? fieldId) => StateHasChanged();

    // Cross-field validation handlers
    private void ShowCrossFieldValidation()
    {
        _editingValidation = null; // New validation
        _showCrossFieldModal = true;
    }

    private void CloseCrossFieldModal()
    {
        _showCrossFieldModal = false;
        _editingValidation = null;
    }

    private void HandleCrossFieldSaved(FieldSetValidation validation)
    {
        if (EditorState.CurrentModule is null) return;

        // Get existing validations or create empty array
        var existingValidations = EditorState.CurrentModule.CrossFieldValidations?.ToList()
            ?? new List<FieldSetValidation>();

        // Add new validation
        existingValidations.Add(validation);

        // Update module with new validations
        var updatedModule = EditorState.CurrentModule with
        {
            CrossFieldValidations = existingValidations.ToArray()
        };
        EditorState.UpdateModule(updatedModule);

        _showCrossFieldModal = false;
        _editingValidation = null;
    }

    public void Dispose()
    {
        EditorState.OnFieldSelected -= OnFieldSelected;
    }
}
